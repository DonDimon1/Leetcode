Нам дана сетка, где мы начинаем с ячейки (вверху слева) и должны двигаться к ячейке (внизу справа). Мы можем двигаться только вправо или вниз. Нам нужно вернуть общее количество уникальных 
путей от начала до конца, используя эти ходы.m x n(0, 0)(m-1, n-1).

Решение - I (грубая сила) [TLE].  Solution - I (Brute-Force) [TLE]. Пройдено 38 / 63 тесткейса дальше ошибка по времени.
Начнем с брутфорс-решения. Для того, чтобы путь был уникальным, по крайней мере, 1 ход должен отличаться в какой-либо ячейке внутри этого пути.

* На каждой клетке мы можем двигаться либо вниз, либо вправо.
* Выбор любого из этих шагов может привести нас к уникальному пути
* Поэтому мы рассматриваем оба этих хода.
* Если серия ходов приводит к ячейке за пределами сетки, мы можем вернуть 0, означающее, что допустимый путь не найден.
* Если последовательность ходов приводит нас к целевой ячейке (m-1, n-1), мы возвращаем 1, означающее, что мы нашли действительный уникальный путь от начала до конца.

class Solution {
public:
    int uniquePaths(int m, int n, int i = 0, int j = 0) {
        if(i >= m || j >= n) return 0;                                    // Если вышел за пределы - решение недействительно
        if(i == m-1 && j == n-1) return 1;                                // Если достигли цели - верное решение
        return uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);     // Пробуем пойти как вниз, так и вправо
    }
};

Нужно найти число уникальных путей. В любой момент времени мы можем пойти либо вниз либо вправо. Проверяем оба пути, затем складываем оба решения.
Временная сложность : O(2^(m+n)), где m и n – заданные входные размерности сетки
Space Complexity : O(m+n), требуемые неявным рекурсивным стеком m n.



Решение - II (Динамическое программирование - Мемоизация) Solution - II (Dynamic Programming - Memoization). 

(Мемоизация - это запомининие).
В приведенном выше решении было много избыточных вычислений. Есть много ячеек, до которых мы доходим несколько раз и вычисляем ответ на них снова и снова. Однако количество уникальных путей от 
данной ячейки (i,j) до конечной ячейки всегда фиксировано. Таким образом, нам не нужно вычислять и повторять один и тот же процесс для данной ячейки несколько раз. Мы можем просто сохранить 
(или запомнить) результат, вычисленный для ячейки (i, j), и использовать этот результат в будущем, когда это потребуется.

Таким образом, здесь мы используем 2d массив dp, где dp[i][j] обозначаем количество уникальных путей от ячейки (i, j) до конечной ячейки (m-1, n-1). Как только мы получаем ответ для 
ячейки (i, j), мы сохраняем результат в dp[i][j] и используем его повторно вместо того, чтобы пересчитывать его.

class Solution {
public:
    int dp[101][101]{};									//2d массив состоящий из нулей.

    int uniquePaths(int m, int n, int i = 0, int j = 0) {
        if(i >= m || j >= n) return 0;							// Если вышел за пределы - решение недействительно
        if(i == m-1 && j == n-1) return 1;						// Если достигли цели - верное решение
        if(dp[i][j]) return dp[i][j];							// Если результат уже рассчитан, то возвращаем его, чтобы не вычислять заново (Оптимизация).
        return dp[i][j] = uniquePaths(m, n, i+1, j) + uniquePaths(m, n, i, j+1);	// Пробуем пойти как вниз, так и вправо. Результат сохраняем в dp[i][j], а затем возвращаем его.
    }
};

Более обобщенное решение должно выглядеть следующим образом:

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n));
        return dfs(dp, 0, 0);
    }
    int dfs(vector<vector<int>>& dp, int i, int j) {
        if(i >= size(dp)   || j >= size(dp[0]))   return 0;     // Если вышел за пределы - решение недействительно
        if(i == size(dp)-1 && j == size(dp[0])-1) return 1;     // Если достигли цели - верное решение
        if(dp[i][j]) return dp[i][j];                           // Если результат уже рассчитан, то возвращаем его, чтобы не вычислять заново (Оптимизация).
        return dp[i][j] = dfs(dp, i+1, j) + dfs(dp, i, j+1);    // Пробуем пойти как вниз, так и вправо. Результат сохраняем в dp[i][j], а затем возвращаем его.
    }
};

При n = 7, m = 3 получим:
28 21 15 10 6 3 1
7  6  5  4  3 2 1
1  1  1  1  1 1 0

Тоже самое что и предыдущее решение, только для оптимизации сохраняем промежуточные результаты, чтобы не вычислять их заново.
Временная сложность : O(m*n), ответ на каждую ячейку вычисляется только один раз и запоминается. Клеток всего m*n и поэтому этот процесс требует времени O(m*n).
Сложность пространства : O(m*n), требуется для поддержания dp.



Решение - III (Динамическое программирование - Табуляция)  Solution - III (Dynamic Programming - Tabulation)

Мы также можем преобразовать приведенное выше решение в итеративную версию. Здесь мы решим ее снизу вверх, итеративно вычислив количество уникальных путей для достижения ячейки (i, j), 
начиная с (0, 0) где (0 <= i <= m-1) и (0 <= j <= n-1). Здесь мы снова воспользуемся динамическим программированием с использованием dp матрицы, где dp[i][j] обозначим количество уникальных 
путей от ячейки (0, 0) к ячейке (i, j). (Обратите внимание, что это отличается от memoization appraoch, где dp[i][j] обозначается количество уникальных путей от ячейки (i, j) к ячейке (m-1,n-1)).

В этом случае мы сначала устанавливаем некоторые базовые условия.

* Начнем с ячейки (0, 0), так что dp[0][0] = 1.
* Поскольку мы можем двигаться только вправо или вниз, есть только один способ добраться до ячейки (i, 0) или (0, j). Таким образом, мы также инициализируем dp[i][0] = 1 и dp[0][j]=1.
* Для каждой второй ячейки (i, j) (где 1 <= i <= m-1 и 1 <= j <= n-1), мы можем добраться сюда либо из верхней ячейки (i-1, j), либо из левой ячейки (i, j-1). Таким образом, результатом 
для числа уникальных путей, к которым нужно прийти (i, j), является суммирование обоих, т.е. dp[i][j] = dp[i-1][j] + dp[i][j-1].

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 1));
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[i][j] = dp[i-1][j] + dp[i][j-1];   // сумма уникальных путей, заканчивающихся в соседних верхней и левой клетках
        return dp[m-1][n-1];         // возвращает уникальные пути, заканчивающиеся в ячейке (m-1, n-1)
    }
};

При n = 7, m = 3 получим:
1 1 1 1  1  1  1
1 2 3 4  5  6  7
1 3 6 10 15 21 28

Итеративный вариант предыдущего решения. dp[i][j] означает количество уникальных путей от ячейки (0, 0) к ячейке (i, j), а не количество уникальных путей от ячейки (i, j) к ячейке (m-1,n-1) как
в прошлом решении.
Временная сложность : O(m*n), мы вычисляем dp значения для каждой из m*n ячеек из предыдущего значения ячейки. Таким образом, общее количество выполненных итераций требует времени O(m*n).
Пространственная сложность : O(m*n), требуется для поддержания dp матрицы.



Решение - IV (Динамическое программирование с оптимизацией пространства)

В приведенном выше решении мы можем наблюдать, что для вычисления dp матрицы мы всегда используем только ячейки из предыдущей строки и текущей строки. Таким образом, нам на самом деле не нужно 
поддерживать всю матрицу m*n. Мы можем оптимизировать использование пространства, сохраняя только текущую и предыдущую строки.

Распространенным способом в dp задачах оптимизации пространства из 2d dp является просто преобразование dp матрицы из m*n сетки в сетку 2*n, обозначающую значения для текущей и предыдущей 
строки. Мы можем просто перезаписать предыдущую строку и использовать текущую строку в качестве предыдущей строки для следующей итерации. Мы можем просто чередовать эти строки с помощью 
оператора & (AND), как видно ниже.

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(2, vector<int>(n,1));
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[i & 1][j] = dp[(i-1) & 1][j] + dp[i & 1][j-1];   // <- &  используется для чередования рядов
        return dp[(m-1) & 1][n-1];
    }
};

Тоже самое, что и предыдущее решение, только для сохранения промежуточных результатов используем всего 2 строки по n элементов в каждой (Оптимизация памяти).

Или, что еще лучше, в этом случае вы можете использовать и один вектор. Мы обращаемся только к одному и тому же столбцу из предыдущей строки, который может быть задан dp[j], 
и к предыдущему столбцу текущей строки, который может быть задан параметром dp[j-1]. Таким образом, приведенный выше код может быть дополнительно упрощен.

class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n, 1);
        for(int i = 1; i < m; i++)
            for(int j = 1; j < n; j++)
                dp[j] += dp[j-1];   
        return dp[n-1];
    }
};

Временная сложность : O(m*n), для вычисления значений dp для каждой из m*n ячеек.
Пространственная сложность : O(n), требуется для поддержания dp. Мы сохраняем только две строки длинной n, что придает пространству сложность O(n).
Есть небольшое изменение, которое может позволить нам оптимизировать сложность пространства до O(min(m, n)).
Прокомментируйте ниже, если сможете разобраться :) Я смогу, не бойся.

Решение - V (Математика)

Эту задачу можно смоделировать как задачу математической комбинаторики.









