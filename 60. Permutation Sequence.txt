//Один из самых быстрых вариантов решения. Интересное решение.
//Предположим, что n = 4, k = 14. Когда n = 4, то массив чисел будет = {1,2,3,4}. Если бы вам пришлось перечислить все имеющиеся перестановки, то они бы равнялись:
//Мы знаем, как посчитать количество перестановок n чисел. Это будет равно n!.
//	1 + (перестановки чисел 2, 3, 4)
//	2 + (перестановки чисел 1, 3, 4)
// 	3 + (перестановки чисел 1, 2, 4)
//	4 + (перестановки чисел 1, 2, 3)
//В скобках у нас 3 числа, т.о. каждая из этих четырёх общих перестановок даст 6 возможных локальных перестановок. Это означает что вообщем у нас имеется 24 перестановки.
//Итак, если бы мы искали k = 14 перестановку она бы находилась в: 
//	3 + (перестановки 1, 2, 4) подмножество.
//Чтобы программно получить это, мы берём k = 13 (вычитаем 1, потому что индекс начинается с 0) и делим на 6 (все возможные локальные перестановки). Это даст нам индекс
//первого нужного числа в массиве {1,2,3,4}. Пример: k/(n-1)! = 13 / (4-1)! = 13/3! = 13/6 = 2. По этому индексу (2) наш массив имеет значение 3. Это и есть первое число 
//искомой перестановки. Затем повторяем идею, но уже с меньшими числами: Перестановки {1, 2, 4} будут следующими:
//
//	1 + (перестановки 2, 4)
//	2 + (перестановки 1, 4)
//	4 + (перестановки 1, 2)
//Но наше k больше не является 14-ым, потому что на предыдущем шаге мы уже исключили 12 перестановок из 4 чисел, начиная с 1 и 2. Итак вычитаем 12 из k, что даёт нам 1:
//	k = k - (индекс от предыдущего) * (n-1)! = k - 2 * (n-1)! = 13 - 2*(3)! = 13 - 12 = 1.
//На втором этапе перестановки двух чисел имеют только две вариации, т.е. каждая из этих трёх общих перестановок даст 2 локальные перестановки, что в сумме даст 
//шесть перестановок. Мы ищем первую перестановку (т.к. k = 1), поэтому она будет в первой перестановке 1 + (перестановки 2, 4): Получаем индекс:
//	k / (n-2)! = 1/(4-2)! = 1/2!= 0. В массиве {1, 2, 4} индекс 0 равен значению 1. Это и есть наше второе число искомой перестановки. 
//Цифры которые у нас уже есть (3, 1). Продолжаем далее:
//
//	2 + (перестановка из 4). 
//k = k - (индекс от предыдущего) * (n-2)! = k - 0 * (n-2)! = 1 - 0 = 1;
//Индек третьего числа = k / (n-3)! = 1/(4-3)! = 1/1! = 1. По индексу 1 в массиве {2, 4} лежит число 4. Третье число равно 4. 
//В массиве осталось только число 2. Здесь единственная перестановка.
//k = k - (индекс от предыдущего) * (n-3)! = k - 1 * (4-3)! = 1 - 1 * 1 = 1 - 1 = 0.
//Индекс четвёртого числа = k / (n-4)! = 0 / (4-4)! = 0/1 = 0. По индексу 0 в массиве {2} лежит число 2. Четвёртое число равное 2.
//Таким образом мы нашли все числа искомой перестановки: 3 1 4 2.


class Solution {
 public:
  string getPermutation(int n, int k) {
    string ans;						//Инициализируем строку ответа
    vector<int> nums(n);				//Инициализируем вектор int размером n
    vector<int> fact(n + 1, 1);  // fact[i] := i!	//Инициализируем вектор int 

    iota(nums.begin(), nums.end(), 1);			//iota заполняет вектор nums в порядке возрастания, начиная с 1. Можно обойтись без неё.

    for (int i = 2; i <= n; ++i)			//Сохраняем факториалы для каждой итерации.
      fact[i] = fact[i - 1] * i;

    --k;  // 0-indexed					//Уменьшаем k на единицу, потому что массив начинается с 0.

    for (int i = n - 1; i >= 0; --i) {			//Проходим по всем общим перестановкам
      const int j = k / fact[i];			//Находим индекс i-ого числа искомой перестановки.
      k %= fact[i];					//Обновляем k
      ans += to_string(nums[j]);			//Получаем значение i-ого числа по найденному индексу и запоминаем число.
      nums.erase(nums.begin() + j);			//Удаляем из исходного массива число по найденному индексу. Его больше не будет.
    }

    return ans;
  }
};







//Мой код. Получился медленный. За основу взял свой код из задания 47. Модифицировал код под работу со строками. Долго вспоминал про дополнительную сортировку.  
class Solution {
public:
    string backTreak(string &num, int &numPre, int k, int numLvl) {
        if (numLvl == num.size() - 1) {
            numPre++;
            if (numPre == k)
                return num;
            else
                return{};
        }
        sort(begin(num) + numLvl, end(num));
        for (int i = numLvl; i < num.size(); i++)
        {
            swap(num[numLvl], num[i]);
            if (!empty(backTreak(num, numPre, k, numLvl + 1)))
                return num;
            swap(num[numLvl], num[i]);
        }
        sort(begin(num) + numLvl, end(num));
        return{};
    }
    string getPermutation(int n, int k) {
        string num;
        for (int i = 1; i <= n; i++)
            num += to_string(i);

        int numPre = 0;
        return backTreak(num, numPre, k, 0);
    }
};