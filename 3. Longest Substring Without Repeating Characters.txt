//Найти подстроку в строке с неповторяющиися симолами

//Оптимизированный код
//Тут на сколько я понимаю размер вектора count состовляет 128
//Это соответствует всему диапозону символов в числовом виде
//(Например если навести на s[r] когда там будет символ 'p' в числовом виде это будет 112)
//В этот вектор на соответствующий индекс доболяется значение 1 
//(В нашем случае индекс 112 будет со значением 1)
//Все остальные индексы пока что равны 0
//В ++count[s[r]]; как раз добовляет в вектор в определённый индекс это значение.
//Цикл while проверяет какое значение в векторе имеет данный индекс
//Если индекс меньше 1 тогда цикл продолжается
//Если индекс больше 1 это значит что такой символ уже был, 
//	значит подстрока c НЕодинаковыми символами закончена
//В --count[s[l++]]; очищает вектор от значений, а также l считает сколько сиволов была данная подстрока
//В ans = max(ans, r - l + 1); Далее вычисляется длина подстроки, для этого
//	число всего прошедших символов и число симолов прошедших в подстроке вычитаются и + 1
//Далее в ans отправляется наибольшее число новыих или старых символов.

class Solution {
 public:
  int lengthOfLongestSubstring(string s) {
    int ans = 0;
    vector<int> count(128);

    for (int l = 0, r = 0; r < s.length(); ++r) {
      ++count[s[r]];
      while (count[s[r]] > 1)
        --count[s[l++]];
      ans = max(ans, r - l + 1);
    }

    return ans;
  }
};

//МОй код
//Первый цикл проходит все буквы
//Второй выбирает следующую букву
//Третий проверяет есть ли в подстроке уже такой символ
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int maxCount = 0;
        for (int i = 0; i < s.length(); i++)
        {
            string subS;
            subS.push_back(s[i]);
            bool proceed = true;
            for (int j = i + 1; j < s.length(); j++)
            {
                for (int k = 0; k < subS.length(); k++)
                {
                    if (subS[k] == s[j])
                    {
                        proceed = false;
                        break;
                    }
                }
                if (proceed == false)
                    break;
                subS.push_back(s[j]);
            }
            if (subS.length() > maxCount)
                maxCount = subS.length();
        }
        return maxCount;
    }
};