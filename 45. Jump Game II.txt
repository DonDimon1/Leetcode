//Мой код. Runtime Beats 97.82%. of users with C++
//Динамическое программирование. Ищем оптимальный ход каждую итерацию, избегая ненужных значений и лишних итераций.
//В начале у нас есть элемент с индексом 0 и его любое натуральное значение(число). Например: nums = { 5, 9, 3, 2, 1, 0, 2, 3, 3, 1, 0, 0 }.
//Мы можем перейти на любой индекс в диапазоне этого значения: i + 5. Для оптимизации мы должны сразу узнать на какой индекс нам выгоднее переходить.
//Для этого мы смотрим какое значение находиться в индексе i + 5: в нашем случае это 0. 
//Теперь расчитываем на какое максимальное кол-во шагов мы можем уйти: i(0) + 5 + 0 = 5. Запоминаем этот индекс. В случае если он окажется максимальным,
//	мы перейдём на него в следующей итерации. В случае когда индекс будет равняться размеру массива nums, завершаем функцию. Далее смотрим значение 
//	в индексе i + 4, i + 3 ... вплоть до i + 1. Перезаписываем максимальный индекс шагов, на которых мы можем уйти, в случае если находим большее 
//	значение. В нашем случае в индексе i + 1 находиться значение 9. Рассчитываем макс. кол-во шагов: 0 + 1 + 9 = 10. Это максимальный индекс. 
//	Поэтому приравниваем i к i + 1 и запускаем новую итерацию. Мы не можем сразу перейти на i + 1 + 9, поскольку это может оказаться неоптимальным 
//	индексом. Так и произошло в нашем случае, значение по индексу i(1) + 9 равняется 0. Получаем максимальный индекс 1 + 9 + 0 = 10. Далее смотрим 
//	предыдущие индексы i + 8, i + 7 ... до i + 1. Максимальное значение в нашем случае будет находиться по индексу 1 + 7 равное 3. 
//	Рассчитываем общий путь по которому мы можем перейти 1 + 7 + 3 = 11. Переходим на следующую итерацию с i = i + 7. Продолжаем пока i + j не будут
//	больше или равны размеру массива nums. Как только это случится, возвращаем кол-во итераций + 1.

class Solution {
public:
    int jump(vector<int>& nums) {
        int i = 0, numsSize = nums.size() - 1;
        int nextIndex = 0;
        int countSteps = 0;
        while (i < numsSize) {
            int	maxIndex = i;
            for (int j = nums[i]; j > 0; j--) {
                int nextStep = i + j;
                if (nextStep >= numsSize)
                    return countSteps + 1;
                int nextValue = nextStep + nums[nextStep];
                if (nextValue > maxIndex) {
                    nextIndex = nextStep;
                    maxIndex = nextValue;
                }
            }
            i = nextIndex;
            countSteps++;
        }
        return countSteps;
    }
};


//Оптимальный.Решение IV (Жадный BFS)
//Мы можем перебирать все индексы, сохраняя самую дальнюю достижимую позицию от текущего индекса - maxReachable и самую дальнюю достигнутую позицию - lastJumpedPos. 
//Каждый раз мы будем пытаться обновить lastJumpedPosиндекс до максимально возможного - maxReachable. Обновление lastJumpedPos отдельно от maxReachable позволяет нам 
//отслеживать jumps необходимый минимум. При каждом lastJumpedPos обновлении jumps также будет обновляться и сохраняться минимальное количество прыжков, необходимое 
//для достижения lastJumpedPos(наоборот, обновление jumpsс помощью maxReachableне даст оптимальное (минимально возможное) значение требуемых прыжков).
//Мы просто вернем его, как только lastJumpedPosдостигнет (или превысит) последний индекс.
//Мы можем попытаться понять шаги в приведенном ниже коде, аналогичные шагам в BFS:
1)maxReachable = max(maxReachable, i + nums[i]): Обновление диапазона следующего уровня. Аналогично queue.push(node)шагу BFS, но здесь мы только жадно сохраняем 
//	максимально достижимый индекс на следующем уровне. 2) i == lastJumpedPos: Когда это становится правдой, итерация текущего уровня завершена. 
//	3)lastJumpedPos = maxReachable: Установить диапазон, до которого нам нужно пройти следующий уровень. 4) jumps++: перейти на следующий уровень.
//	5)return jumps: Окончательный ответ будет количеством уровней прохождения BFS.

//Своими словами: он проходит каждый элемент массива. На каждом элементе вычисляем максимально достижимый индекс maxReachable. С помощью lastJumpedPos узнаёт 
сколько шагов прошлёл. Каждый раз когда i доходит до lastJumpedPos, + 1 шаг и lastJumpedPos = maxReachable.
int jump(vector<int>& nums) {
	int n = size(nums), i = 0, maxReachable = 0, lastJumpedPos = 0, jumps = 0;
	while(lastJumpedPos < n - 1) {  // зацикливаемся до тех пор, пока последний прыжок не доведёт нас до конца
		maxReachable = max(maxReachable, i + nums[i]);  // самый дальний индекс, достижимый на следующем уровне от текущего уровня
		if(i == lastJumpedPos) {			  // текущий уровень прошел итерацию, и позиция maxReachable на следующем уровне была определена окончательно
			lastJumpedPos = maxReachable;     // поэтому просто перемещаемся в эту maxReachable позицию
			jumps++;                          // и увеличиваем уровень
	// ПРИМЕЧАНИЕ: jump^ обновляется только после того, как мы проверим все возможные прыжки с предыдущего уровня.
	//       Это гарантирует, что прыжки будут хранить только минимальный прыжок, необходимый для достижения lastJumpedPos
		}            
		i++;
	}
	return jumps;
}