//Сам не решил 204 / 210 тесткейсов. Жесть, на первый взгляд задача показалась лёгкой. Нужно найти подмассив, в котором сумма элементов будет максимальна. Если нет
//	отрицательных чисел, то этот подмассив будет равен всему исходному массиву. Однако с отрицательными числами сложнее. 
//Решается оптимально с помощью алгоритма Кадана. Смысл алгоритма в том, что мы с каждой итерацией ищем максимальный локальный подмассив и сохраняем его.(DP). 
//На каждой i-ой итерации возможно только два случая: если мы знаем сумму наибольшего подмассива T[i], оканчивающегося в i, то следующий элемент либо расширяет его, 
//	либо начинает новый подмассив. Тоесть T[i + 1] может быть либо T[i] + A[i + 1], либо A[i + 1]. Соответственно на i-ом элементе максимальная сумма подмасива
//	будет равна либо сумме всех предыдущих элементов + элемент i, либо текущему элементу i. Ищем максимальное значение между ними, сохраняем его, 
//	и идём на следующую итерацию.

class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();//Для окончания цикла.
        int maxValue = INT_MIN, sum = 0;//Начальное значение i-ого элемента равно минимально возможному значению типа int. Общая сумма пока равна нулю.

        for (int i = 0; i < n; i++) {//Перебор всех элементов массива
            sum = max(sum + nums[i], nums[i]);//Сравниваем максимальное значение между суммой значений всех элементов до элемента i + значение элемента i или просто значение элемента i. Максимальное значение записываем в сумму.
            maxValue = max(sum, maxValue);//Сравниваем локальное максимальное значение и основное максимальное значение. Максимальное значение записываем.
        }
        return maxValue;
    }
};



//Тоже самое только с одним вызовом функции max.(ХЗ быстрее или нет я так и не понял.)
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();//Для окончания цикла.
        int maxValue = INT_MIN, sum = 0;//Начальное значение i-ого элемента равно минимально возможному значению типа int. Общая сумма пока равна нулю.

        for (int i = 0; i < n; i++) {//Перебор всех элементов массива
            sum += nums[i];//Суммируем все элементы массива. (в первой итерации сумма sum равна значению первого элемента массива nums).
            maxValue = max(sum, maxValue);//Узнаём максимальное значение локального подмассива. Для этого сравниваем сумму всех предыдущих элементов массива nums + значение i и уже имеющиеся максимальное значение.

            if (sum < 0) sum = 0;//Если сумма элементов меньше 0, то приравниваем её к 0.
        }
        return maxValue;
    }
};



//Моё решение. Оптимально не смог решить, только грубой силой. Однако на 204 / 210 тесткейсов ошибка рантайма. (Слишком долго). Массив nums очень большой.
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxValue = nums[0];
        for (int i = 0; i < nums.size(); i++) {
            int tempMaxValue = nums[i];
            for (int j = i + 1; j < nums.size(); j++) {
                if (tempMaxValue > maxValue)
                    maxValue = tempMaxValue;
                tempMaxValue += nums[j];
            }
            if (tempMaxValue > maxValue)
                maxValue = tempMaxValue;
        }
        return maxValue;
    }
};