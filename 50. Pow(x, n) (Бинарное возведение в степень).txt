//Мой код слишком медленный. Чтобы ускорить его пребегнем к математике. Вот алгоритм Бинарного возведения в стемень. https://ru.algorithmica.org/cs/algebra/binpow/
//Бинарное возведение в степень — приём, позволяющий возводить любое число в n-ую степень за O(log n) умножений (вместо n умножений при обычном подходе).
//Основная идея: Заметим, что для любого числа a и чётного числа n выполняется тождество:
//	a^n = (a^(n/2))^2 = a^(n/2) * a^(n/2).
//Получается, что для любого чётного n мы можем свести задачу к вдвое меньшей (n' = n / 2), потратив всего одну операцию умножения.
//Если же n нечётно, то верно следующее: a^n = a^(n-1) * a. Получается, для нечетных n мы можем сделать сведение к задаче размера (n−1), которая уже будет чётной.
//Формула для подсчёта a^n = f(a, n): Если n = 0, то возвращаем 1. Если n % 2 == 1, то возвражаем f(a, n - 1) * a. Если n % 2 == 0, то возвращаем f(a, n/2)^2.

//Пример: Вычислить 2^10. (Сначала опускаемся вниз).
//2^10 = 2^(10/2) * 2^(10/2) = 2^5 * 2^5 		    32 * 32 = 1024 --> --> 2^10 = 1024
//2^5 = 2^(5 - 1) * 2 = 2^4 * 2				    16 * 2 = 32
//2^4 = 2^(4/2) * 2^(4/2) = 2^2 * 2^2			    4 * 4 = 16
//2^2 = 2^(2/2) * 2^(2/2) = 2^1 * 2^1			    2 * 2 = 4
//2^1 = 2^(1 - 1) * 2 = 2^0 * 2				    1 * 2 = 2
//2^0 = 1 	-->	-->	-->	-->	-->	--> 2^0 = 1 

//Реализация рекурсией. Просто, однако из-за рекурсии код очень долго работает. Нужно ускорить, для этого попробуем составить итерационный алгоритм.
double myPow(double x, int n) {
	if (n == 0)
		return 1;
	if (n % 2 == 1)
		return myPow(x, n - 1) * x;
	else {
		double b = myPow(x, n / 2);
		return b * b;
	}
}

//Рассмотрим двоичное представление числа n. Результат a^n можно представить как произведение a в степенях каких-то степеней двоек. 
//	Например, если n = 42 = 32 + 8 + 2, то a^42 = a^(32+8+2) = a^32 * a^8 * a^2.
//Чтобы посчитать это произведение итеративно, пройдемся по всем битам числа n, поддерживая две переменные: непосредственно результат и текущее значение a^(2^k) (т.е. переменная x в коде ниже), 
//	где k это номер текущей итерации. Если k-тый (последний) бит числа n единичный, то будем домножать a^(2^k) на текущий результат (Типо число нечётное). 
//	И в любом случае на каждом шаге возводить её в квадрат, получая a^((2^k) * 2) = a^(2^(k + 1)) для следующей итерации.

double myPow(double x, int n) {
	int res = 1;				//Стартовый результат = 1				
	while (n != 0) {			//Пока степень не будет = 0
		if (n & 1)			//Если k-тый бит числа n единичный(& - поразрядная конъюнкция AND)(Если число нечётное)
			res *= x;		//Домнажаем a^(2^k) на текущий результат (Записываем результат)
		x = x * x;			//Возводим a^(2^k) в квадрат для следующей итерации
		n >>= 1;			//Переходим к предыдущему биту числа n(степени)
	}
	return res;
}

//Пример: Вычислить 2^10. x = 2. Степень n = 10. В начале результат = 1. Цикл идёт пока n не ровно 0. Число n в двоичном виде = 1010. Число 1 в двоичном виде 0001. 
//Сравниваем (& - поразрядная конъюнкция AND) текущую степень n с единицой: 1010: Последний бит в результате равен 0, значит число чётное, пропускаем if. Возводим наше число x 
//					    				    0001	в квадрат получаем x = x*x = 4, и смещаем двоичное число n на 1 разряд вправо. 
//								 результат: 0000        Получаем число 5 (в 10ой) или 101 (в 2ой) системах.
//
//Поскольку n не равно 0, повторяем цикл. Сравниваем текущую степень n с единицей: 101: Последний бит в результате равен 1, значит число нечётное, заходим в if.  
//										   001	      Домножаем a^(2^k) (т.е. x) на текущий результат res. Т.е. записываем res = res * x = 1 * 4 = 4. 
//								        результат: 001	      Возводим наше число x в квадрат, получаем x = x*x = 16 и смещаем двоичное число на 1 разряд вправо.
//										       	      Получаем n = 2 (в 10ой) или 10 (в 2ой).
//
//Поскольку n не равно 0, повторяем цикл. Сравниваем текущую степень n с единицей: 10: Последний бит в результате равен 0, значит число чётное, пропускаем if. Возводим число
//										   01	    x в квадрат, получаем x = x*x = 256 и смещаем двоичное число n на 1 разряд вправо.
//									результат: 00	    Получаем n = 1 (в 10ой) или 1 (в 2ой).
//
//Поскольку n не равно 0, повторяем цикл. Сравниваем текущую степень n с единицей: 1: Последний бит в результате равен 1, значит число нечётное, заходим в if.
//										   1	    Домножаем a^(2^k) (т.е. x) на текущий результат res. Т.е. записываем res = res * x = 4 * 256 = 1024. 
//									результат: 1	    Возводим наше число x в квадрат, получаем x = x*x = 65536 и смещаем двоичное число n на 1 разряд вправо.
//											    Получаем n = 0 (в 10ой) или 0 (в 2ой). 
//Поскольку n == 0 заканчиваем цикл и возвращаем результат res.

//Итерационное решение с сайта с алгоритмами. Сам я дошёл к сожалению только до 305/306 тесткейсов. Последний был слишком долгий.
class Solution {
public:
    double recursion(double x, long n) {
        double res = 1;					//Стартовый результат = 1
        while (n != 0) {				//Пока степень не будет = 0
            if (n & 1)					//Если k-тый (последний) бит числа n единичный
                res *= x;				//Домнажаем a^(2^k) на текущий результат
            x = x * x;					//Возводим a^(2^k) в квадрат для следующей итерации
            n >>= 1;					//Переходим к следующему биту
        }
        return res;
    }
    double myPow(double x, int n) {
        long N = n;
        if(x == 1)
            return 1;
        if (n < 0) {
            return 1 / recursion(x, -N);
        }
        else
            return recursion(x, n);
    }
};
















