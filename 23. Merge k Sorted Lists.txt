//Чужой код
ListNode* mergeKLists(vector<ListNode*>& lists) {
	int K = lists.size();//Кол-во элементов в векторе lists
	ListNode *head = new ListNode(-1), *temp = head;//head указатель на новую структуру c val = -1;
	//Указатель temp указывает на первый узел связанных списков head
	priority_queue<int, vector<int>, greater<int> > pq;//Создание преоритетной очереди.
	//int это тип элементов, которые вы хотите сохранить в очереди приоритетов.
	//vector<int> это тип внутреннего контейнера, используемого для хранения этих элементов.
	//greater<int>> pq это пользовательская функция сравнения. Это определяет, как элементы упорядочиваются в очереди приоритетов.
	//Оператор greater проверяет, больше ли первый аргумент второго
	for (int i = 0; i < K; i++) {//Цикл по всем элементам вектора lists
		ListNode *temp1 = lists[i];//Указатель на i-ый элемент вектора lists(первый узел списка)
		while (temp1 != NULL) {//элемент списка temp1 не пустой
			pq.push(temp1->val);//Добавляем его в преоритетную очередь
			temp1 = temp1->next;//Переходим к следующему узлу списка temp1
		}
	}
	while (!pq.empty()) {//Пока очередь не пуста
		ListNode *newNode = new ListNode(pq.top());//Создаём место для укзателя newNode на структуру ListNode с параметром val = верхнему значению очереди pq(в нашем случае это минимальное значение). 
		pq.pop();//Удаляет верхний элемент очереди pq(в нашем случае минимальный элемент).
		head->next = newNode;//Добавлям эту структуру в финальный связный список.
		head = head->next;//Переход к следущему узлу фин. списка для сохранения.
	}
	return temp->next;//Возвращаем второй элемент связанного списка(Первый равен -1 и нужен только для задания начала фин. списка)
}


//Мои коды. Они работают в VS. НО в leetcode возникает ошибка runtime error: member access within null pointer of type 'ListNode' (solution.cpp).
Хуй знает почему.(ИДея была правильная)
#include <iostream>
#include <cmath>
//#include <stdio.h>
#include <string> // Работа со строками
#include <fstream> // Работа с файлами в стиле C++
#include <conio.h> //Обработка нажатия на клавиши
#include <Windows.h>
#include <WinCon.h>//Для выделения текста в консоли
#include <vector>
#include <algorithm>



using namespace std;
struct ListNode {
	int val;
	ListNode *next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode *next) : val(x), next(next) {}
};
ListNode* mergeKLists(vector<ListNode*>& lists) {
	ListNode answer;
	vector<int> listVal;
	for (int i = 0; i < lists.size(); i++)
	{
		ListNode *temp = lists.at(i);
		while (temp)
		{
			listVal.push_back(temp->val);
			temp = temp->next;
		}
	}
	sort(begin(listVal), end(listVal));
	ListNode *temp = &answer;
	for (int i = 0; i < listVal.size(); i++)
	{
		ListNode *next = new ListNode;
		temp->val = listVal.at(i);
		if (i == listVal.size())
		{
			temp->next = NULL;
			break;
		}
		temp->next = next;
		temp = temp->next;
	}
	return &answer;
}

int main()
{
	setlocale(LC_ALL, "Russian");// Русский язык в консоли
	ListNode l1, l2, l3;
	l1.val = 1;
	l1.next = &l2;
	l2.val = 4;
	l2.next = &l3;
	l3.val = 5;
	l3.next = NULL;
	ListNode k1, k2, k3;
	k1.val = 1;
	k1.next = &k2;
	k2.val = 3;
	k2.next = &k3;
	k3.val = 4;
	k3.next = NULL;
	ListNode j1, j2;
	j1.val = 2;
	j1.next = &j2;
	j2.val = 6;
	j2.next = NULL;
	//vector<ListNode*> lists = {&l1,&l2,&l3,&k1,&k2,&k3,&j1,&j2};
	vector<ListNode*> lists = { &l1,&k1,&j1 };
	ListNode* answer = mergeKLists(lists);

}


/////////////////////////////////////////////////////////////Вариант 2 без векторов только расчёты

#include <iostream>
#include <cmath>
//#include <stdio.h>
#include <string> // Работа со строками
#include <fstream> // Работа с файлами в стиле C++
#include <conio.h> //Обработка нажатия на клавиши
#include <Windows.h>
#include <WinCon.h>//Для выделения текста в консоли
#include <vector>
#include <algorithm>



using namespace std;
struct ListNode {
	int val;
	ListNode *next;
	ListNode() : val(0), next(nullptr) {}
	ListNode(int x) : val(x), next(nullptr) {}
	ListNode(int x, ListNode *next) : val(x), next(next) {}
};
ListNode* mergeKLists(vector<ListNode*>& lists) {
	ListNode firstNode;
	ListNode *temp = &firstNode;
	int count = 0;
	while (!lists.empty()) {
		int minValue = lists.at(0)->val;
		int indexMinList = 0;
		for (int i = 0; i < lists.size(); i++)
		{
			int currentValue = lists.at(i)->val;
			if (currentValue < minValue)
			{
				minValue = currentValue;
				indexMinList = i;
			}
		}
		ListNode *nextList = new ListNode;
		temp->val = lists.at(indexMinList)->val;
		temp->next = nextList;
		if (lists.at(indexMinList)->next != NULL)
			lists.at(indexMinList) = lists.at(indexMinList)->next;
		else {
			lists.erase(lists.begin() + indexMinList);
			if(lists.empty()){
				temp->next = NULL;
				break;
			}		
		}
		temp = temp->next;
		count++;
	}
	return &firstNode;
}

int main()
{
	setlocale(LC_ALL, "Russian");// Русский язык в консоли
	ListNode l1, l2, l3;
	l1.val = 1;
	l1.next = &l2;
	l2.val = 4;
	l2.next = &l3;
	l3.val = 5;
	l3.next = NULL;
	ListNode k1, k2, k3;
	k1.val = 1;
	k1.next = &k2;
	k2.val = 3;
	k2.next = &k3;
	k3.val = 4;
	k3.next = NULL;
	ListNode j1, j2;
	j1.val = 2;
	j1.next = &j2;
	j2.val = 6;
	j2.next = NULL;
	//vector<ListNode*> lists = {&l1,&l2,&l3,&k1,&k2,&k3,&j1,&j2};
	vector<ListNode*> lists = { &l1,&k1,&j1 };
	ListNode* answer = mergeKLists(lists);

}